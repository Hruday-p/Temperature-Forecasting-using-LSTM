# -*- coding: utf-8 -*-
"""Temperature-Forecast-using-LSTM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15DxaG1ejqqO0nZnW5oQqY4KBGdq9G5Lp
"""

import pandas as pd
import numpy as np
import datetime

import tensorflow as tf
from tensorflow.keras.layers import LSTM

data = pd.read_csv("/content/predictive_maintenance_dataset.csv")
data.head()

data['Timestamp'] = pd.to_datetime(data['Timestamp'])

train_size = int(len(data)*0.8)
train_data = data[:train_size]
test_data = data[train_size:]

train_temp = train_data['Temperature'].values
test_temp = test_data['Temperature'].values

from sklearn.preprocessing import MinMaxScaler

# Scale the data
scaler = MinMaxScaler(feature_range=(0, 1))
train_temp_scaled = scaler.fit_transform(train_temp.reshape(-1, 1))
test_temp_scaled = scaler.transform(test_temp.reshape(-1, 1))

def create_sequences(data, time_steps):
    X, y = [], []
    for i in range(len(data) - time_steps):
        X.append(data[i:(i + time_steps), 0])
        y.append(data[i + time_steps, 0])
    return np.array(X), np.array(y)

time_steps = 24 # Use 24 past hourly readings to predict the next hour

X_train, y_train = create_sequences(train_temp_scaled, time_steps)
X_test, y_test = create_sequences(test_temp_scaled, time_steps)

# Reshape input to be [samples, time_steps, features]
X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)
X_test = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)

print(f"Shape of X_train: {X_train.shape}")
print(f"Shape of y_train: {y_train.shape}")
print(f"Shape of X_test: {X_test.shape}")
print(f"Shape of y_test: {y_test.shape}")

"""Now that the data is preprocessed and in the correct shape, let's build the LSTM model."""

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

model = Sequential()
model.add(LSTM(units=50, return_sequences=True, input_shape=(time_steps, 1)))
model.add(LSTM(units=50))
model.add(Dense(units=1))

model.compile(optimizer='adam', loss='mean_squared_error')
model.summary()

"""The LSTM model is defined. Now, let's train it using the prepared training data."""

history = model.fit(X_train, y_train, epochs=20, batch_size=32, validation_split=0.1, verbose=1)

"""The model has been trained. Next, we'll make predictions on the test set and evaluate the model's performance."""

predictions = model.predict(X_test)

# Inverse transform the predictions and actual values to original scale
predictions = scaler.inverse_transform(predictions)
y_test_actual = scaler.inverse_transform(y_test.reshape(-1, 1))

from sklearn.metrics import mean_squared_error
from math import sqrt

rmse = sqrt(mean_squared_error(y_test_actual, predictions))
print(f"Test RMSE: {rmse:.2f}")

"""Let's visualize the actual vs. predicted temperatures."""

plt.figure(figsize=(14, 7))

# Get the last 500 values from the test set
num_points = 500
# Ensure time_steps is accounted for in indexing test_data to match y_test_actual and predictions
start_index = len(y_test_actual) - num_points

plt.plot(test_data['Timestamp'][time_steps:].iloc[start_index:], y_test_actual[start_index:], label='Actual Temperature', color='blue')
plt.plot(test_data['Timestamp'][time_steps:].iloc[start_index:], predictions[start_index:], label='Predicted Temperature', color='red', linestyle='--')

plt.title('Actual vs. Predicted Temperature on Last 500 Test Data Points')
plt.xlabel('Timestamp')
plt.ylabel('Temperature')
plt.legend()
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()